{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to MkDocs","text":""},{"location":"index.html#welcome-to-mkdocs","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"0_Modelo_Capas.html","title":"Modelo Capas","text":""},{"location":"0_Modelo_Capas.html#modelo-de-capas","title":"Modelo de Capas.","text":""},{"location":"0_Modelo_Capas.html#por-que-el-modelo-de-capas","title":"\u00bfPor qu\u00e9 el modelo de capas?","text":"<p>La comunicaci\u00f3n mediante las redes es posible gracias a los diferentes protocolos que han sido programados en los dispositivos. No obstante, si cada fabricante programara su propio protocolo (protocolo propietario), sin seguir ning\u00fan est\u00e1ndar universal, ser\u00eda pr\u00e1cticamente imposible que dispositivos de diferentes fabricantes pudieran comunicarse entre si.</p> <p>Para solventar esta problem\u00e1tica se implementa/propone el modelo de capas, donde se especificaban diferentes niveles, cada nivel acog\u00eda m\u00faltiples protocolos, pero dichos protocolos ten\u00edan que cumplir unas normas b\u00e1sicas dependiendo a la capa a la que pertenecieran. </p>"},{"location":"0_Modelo_Capas.html#que-es-un-protocolo","title":"\u00bfQu\u00e9 es un protocolo?","text":"<p>Un protocolo son una serie de normas/reglas que cada dispositivo debe cumplir para poder hacer cierta tarea (dependiendo del protocolo implementado).</p> <ul> <li> <p>Podemos aprovechar mejor el hardware de la m\u00e1quina anfitriona, ya que estamos ejecutando varios \"ordenadores\" en uno mismo, aprovechando recursos que de otra forma es posible que no se llegaran a usar.</p> </li> <li> <p>Permite ejecutar software que quiz\u00e1 sea incompatible con tu sistema operativo anfitri\u00f3n, ya sea por un motivo de versiones o porque son sistemas operativos diferentes (Windows, Linux, MAC).</p> </li> </ul> <p>Ejemplos de protocolos:</p> <p>\ud83d\udca5 Protocolo ARP: Protocolo que permite a partir de una direcci\u00f3n IP encontrar su direcci\u00f3n f\u00edsica o MAC (capa 2~3).</p> <p>\ud83d\udca5Protocolo IP: Sirve para llevar a cabo la comunicaci\u00f3n a trav\u00e9s de paquetes IP (capa 3).</p> <p>\ud83d\udca5Protocolo TCP/UDP: Protocolos de comunicaci\u00f3n mediante segmentos (capa 4).</p> <p>\ud83d\udca5Protocolo HTTP: Protocolo de aplicaci\u00f3n que permite a partir de un texto plano representar una p\u00e1gina web a trav\u00e9s de un navegador (capa 5)</p> <p>En el mundo de las redes cada protocolo va ligada a una capa o nivel. Es decir, que si hubiera un problema con el protocolo IP (capa 3), solo debemos de centrarnos en las tareas que se realizan en la capa 3, y la soluci\u00f3n a dicho problema lo encontraremos con herramientas o conocimientos que afecten a ese nivel.\u00e7</p> <p>Como hemos dicho cada capa se encarga de sus propios protocolos, aisl\u00e1ndose de los protocolos del resto de capas. No obstante una capa siempre se comunicar\u00e1 con su capa inmediatamente superior o inferior, dependiendo de la direcci\u00f3n de la comunicaci\u00f3n. Por ejemplo, la capa 4, \u00fanicamente podr\u00e1 comunicarse con la capa 3 o con la capa 5.</p> <p>Modelo de referencia OSI.</p> <p>En un primer lugar se crea un modelo de 7 capas, totalmente te\u00f3rico, que nunca lleg\u00f3 a ponerse en pr\u00e1ctica, pero que s\u00ed sirvi\u00f3 de base a otros modelos.</p> <p>Modelo de facto TCP/IP.</p> <p>Este modelo es el que se usa actualmente en la pr\u00e1ctica, se basa en el modelo OSI pero tiene 4 capas.</p> <p>En el modelo TCP/IP se agrupan en una misma capa el nivel  f\u00edsico y de enlace de datos. No obstantes nosotros s\u00ed las dividiremos y hablaremos de capa 1 (capa f\u00edsica) y capa 2 (enlace de datos o acceso a la red).</p> <p>NOTA</p> <p></p> A partir de ahora se har\u00e1 referencia a este modelo (TCP/IP con 5 capas)."},{"location":"0_Modelo_Capas.html#encapsulamiento","title":"Encapsulamiento.","text":"<p>Hemos dicho que un protocolo pertenece a una capa, pero tambi\u00e9n se ha comentado que cada capa se comunica con su capa inmediatamente superior o inferior, dependiendo de si est\u00e1 recibiendo el mensaje o envi\u00e1ndolo.</p> <p>Env\u00edo de informaci\u00f3n.</p> <ul> <li> <p>Cuando enviamos informaci\u00f3n habitualmente se genera en una aplicaci\u00f3n (capa 5), y dichos datos van bajando por la pila de red, es decir, pasa a la capa 4, luego la 3, luego la 2, etc\u2026</p> </li> <li> <p>En cada capa habr\u00e1 un protocolo encargado de hacer algo que permita la comunicaci\u00f3n.</p> </li> <li> <p>Por ejemplo, alguna vez leer\u00e9is que HTTP (capa 5) es un protocolo que funciona mediante TCP (capa 4), haciendo uso de IP (capa 3) y a su vez de Ethernet (capa 2). </p> </li> <li> <p>Cada vez que se env\u00eda informaci\u00f3n, a medida que baja de capa en capa, se va a\u00f1adiendo informaci\u00f3n de cada protocolo, por tanto se van encapsulando cabeceras.</p> </li> </ul> <p>Recepci\u00f3n de informaci\u00f3n.</p> <ul> <li> <p>Cuando recibimos informaci\u00f3n se produce el caso contrario, no lo recibe una aplicaci\u00f3n, si no que dicha informaci\u00f3n primero llega a trav\u00e9s de un medio (cable, fibra, aire) a nuestra tarjeta de red (capa 1), haciendo uso de ciertos protocolos como Ethernet (capa 2), IP (capa 3) y TCP (capa 4) llega finalmente al protocolo que s\u00ed puede comunicarse con la aplicaci\u00f3n, en el caso de HTTP un navegador.</p> </li> <li> <p>En este caso de recibir informaci\u00f3n, en el paso de las capas, de la 1 a la 5, se va aligerando el tama\u00f1o de los datos, es decir, se van desencapsulando las cabeceras.</p> </li> </ul> <p>NOTA</p> <p></p> Obviamente dependiendo del protocolo usado, las cabeceras que se a\u00f1aden a los datos son diferentes, pero siempre en cada nivel se a\u00f1ade o quita una cabecera."},{"location":"0_Modelo_Capas.html#pdu-protocol-data-unit","title":"PDU (Protocol Data Unit).","text":"<p>A nivel de nomenclatura, cada vez que los datos pasan por una capa con sus susodichas cabeceras van recibiendo nombres diferentes. Es decir, cuando a los datos se le a\u00f1ade la cabecera IP en la capa 3, se le pasa a llamar paquete, en caso de que estar en la capa 4 ser\u00e1 un segmento (TCP) o datagrama (UDP), etc.</p>"},{"location":"1_ConocimientosBasicos.html","title":"Conocimientos B\u00e1sicos","text":""},{"location":"1_ConocimientosBasicos.html#conocimientos-basicos-l2-capa-2","title":"Conocimientos b\u00e1sicos L2 (Capa 2).","text":""},{"location":"1_ConocimientosBasicos.html#direccion-fisica-o-mac-media-access-control","title":"Direcci\u00f3n F\u00edsica o MAC (Media Access Control).","text":"<ul> <li> <p>Todo dispositivo que tenga una tarjeta de red (al\u00e1mbrica, inal\u00e1mbrica, bluetooth, etc.) tiene una direcci\u00f3n MAC.</p> </li> <li> <p>Cada direcci\u00f3n MAC es \u00fanica, es decir, dos dispositivos de mismo o diferente fabricante no pueden tener la misma direcci\u00f3n MAC.</p> </li> <li> <p>La direcci\u00f3n MAC de un adaptador de red no se puede modificar, aunque s\u00ed podemos enviar tramas modificando el campo que muestra nuestra direcci\u00f3n MAC. Es decir, que podemos enviar tramas modificando nuestra MAC, pero si alguien se hace f\u00edsicamente con nuestro equipo podr\u00e1 ver la MAC verdadera de nuestro adaptador.</p> </li> <li> <p>La MAC est\u00e1 representada por 48 bits, dispuestos mediante 12 d\u00edgitos hexadecimales. Por ejemplo 00:1e:c2:ff:78:ad.</p> </li> <li> <p>Los primeros 3 pares de hexadecimales hacen referencia al fabricante (OUI).</p> </li> <li> <p>Lo \u00faltimos 3 pares de hexadecimales hacen referencia al dispositivo.</p> </li> <li> <p>Existen p\u00e1ginas que nos indican una MAC a que empresa pertenece.</p> <p>\ud83d\udca5https://www.wireshark.org/tools/oui-lookup.html</p> </li> </ul> <p>Tipos de direcciones MAC.</p> <p>\ud83d\udca5 Unicast: Son direccionas MAC que van dirigidas a un dispositivo en concreto. </p> <p>\ud83d\udca5 Broadcast: Es una direcci\u00f3n MAC especial (ff:ff:ff:ff:ff:ff) que indica que se debe enviar a todos los dispositivos.</p> <p>\ud83d\udca5 Multicast: La trama se env\u00eda a un grupo de dispositivos. Comienzan con el OUI 01:00:5e.</p>"},{"location":"1_ConocimientosBasicos.html#trama-ethernet","title":"Trama Ethernet:","text":"<p>Ethernet es uno de los protocolos m\u00e1s habituales en la capa 2. El objetivo es hacer hincapi\u00e9 en que cada protocolo tiene sus cabeceras, cada uno con una raz\u00f3n de ser. Comprender en profundidad un protocolo nos puede ayudar a defendernos o a pensar en posibles ataques a realizar.</p> <ul> <li> <p>Pre\u00e1mbulo: Sirve para saber cu\u00e1ndo empieza y acaba una trama. Si recibe la secuencia 10101010 quiere decir que comienza una trama, si recibe la secuencia 10101011 es que acaba la trama.</p> </li> <li> <p>Dest.Addr/Source Addr: Son las direcciones MAC del destinatario y del origen. Se pone primero el destino porque algunos equipos de red al leer el destino env\u00edan directamente la trama para ser m\u00e1s r\u00e1pidos.</p> </li> <li> <p>Type: Tipo de protocolo de capa 3 encapsulado.</p> </li> <li> <p>Data: Datos que transporta.</p> </li> <li> <p>FCS: Para la detecci\u00f3n de errores durante el transporte.</p> </li> </ul>"},{"location":"1_ConocimientosBasicos.html#hubs-o-concentradores","title":"HUBs o Concentradores.","text":"<p>Son equipos obsoletos que debemos evitar.</p> <ul> <li> <p>F\u00edsicamente son muy parecidos a los switches/conmutadores.</p> </li> <li> <p>Su principal problema es que cuando reciben una trama lo env\u00edan a todos los puertos excepto por aquel por donde ha recibido la trama. Por lo que se genera tr\u00e1fico redundante y adem\u00e1s todo el mundo ser\u00eda capaz de recoger el tr\u00e1fico de los dem\u00e1s poniendo las tarjetas de red en modo promiscuo.</p> </li> <li> <p>El modo promiscuo no es m\u00e1s que decirle  a tu adaptador de red que capture tambi\u00e9n el tr\u00e1fico cuya MAC de destino no sea la suya.</p> </li> <li> <p>Adem\u00e1s solo tiene un mismo dominio de colisi\u00f3n, esto quiere decir que si la computadora A env\u00eda una trama a la vez que el PC B, se producir\u00e1 una colisi\u00f3n y tendr\u00e1n que volver a reenviar las tramas otra vez hasta que no se produzca una colisi\u00f3n.</p> </li> </ul> <p>Por supuesto el dominio de broadcast es compartido, por lo que si un equipo env\u00eda una mensaje broadcast lo reciben todos.</p>"},{"location":"1_ConocimientosBasicos.html#switches","title":"Switches","text":"<ul> <li> <p>Un mensaje Unicast solo se env\u00eda al puerto donde se encuentre el destinatario. Es por tanto m\u00e1s seguro que un HUB.</p> </li> <li> <p>Un mensaje Broadcast se env\u00eda por todos los puertos, al no ser que haya sido segmentado mediante VLANs.</p> </li> <li> <p>Existe un dominio de colisi\u00f3n por puerto, es decir, que si el PC A env\u00eda una trama y el PC B env\u00eda otra, al estar en puertos diferentes no se produce una colisi\u00f3n. Por lo tanto tiene much\u00edsimo mejor rendimiento que un hub.</p> </li> <li> <p>La conmutaci\u00f3n (capa 2) es m\u00e1s r\u00e1pida que el enrutamiento de los routers (capa 3).</p> </li> <li> <p>Existen switches gestionables y no gestionables.</p> <p>\ud83d\udca5 Para la ciberseguridad siempre es recomendable hacer uso de switches gestionables.</p> </li> <li> <p>Existen switches L3, que tienen funcionalidades de router, aunque habitualmente no soportan tantos protocolos/funcionalidades como un router.</p> </li> </ul> <p>\u00bfQu\u00e9 es la tabla CAM (Content Addressable Memory)?</p> <p>La tabla CAM (el nombre puede cambiar dependiendo del fabricante), es una tabla donde el switch almacena las MAC que conoce y el puerto por donde las conoci\u00f3.</p> <p>El tipo de direcci\u00f3n es din\u00e1mica o est\u00e1tica. </p> <ul> <li> <p>Din\u00e1mica es aprendida por el switch al recibir una petici\u00f3n.</p> </li> <li> <p>Est\u00e1tica es que ha sido configurada a mano por un administrador.</p> </li> </ul> <p>\u00bfQu\u00e9 pasa si se llena la tabla CAM?</p> <p>La tabla CAM tiene una memoria asignada, especialmente en equipos antiguos o baratos esta memoria no es muy grande. Cuando se llena y no puede almacenar m\u00e1s entradas el switch env\u00eda la trama recibida a todos los puertos, a la vez que elimina las entradas m\u00e1s antiguas e inserta las nuevas.</p> <p>CAM overflow attack</p> <p></p> Es un ataque que llena la tabla CAM con MACs falsas constantemente, de esta forma el switch comienza a mandar el tr\u00e1fico del resto de equipos reales como si fuera broadcast.  <p>\u00bfQu\u00e9 pasa cuando un switch recibe una trama?</p>"},{"location":"1_ConocimientosBasicos.html#protocolo-arp-address-resolution-protocol","title":"Protocolo ARP (Address Resolution Protocol).","text":"<p>Es un protocolo cuyo objetivo es averiguar la direcci\u00f3n MAC de una IP. </p> <p>Cualquier host (ordenador, tablet, m\u00f3vil, servidor, \u2026) necesita tanto de la MAC como de la IP para comunicarse con otros hosts. Para ello dispone de una tabla ARP donde tiene un listado de las IPs/MACs que conoce.</p> <p>Imaginemos que queremos llegar a una IP, pero no sabemos su MAC \u00bfqu\u00e9 rellenamos en el campo direcci\u00f3n destino de nuestra trama?</p> <p>Ejemplo:</p> <p>1. El \u201cPC A\u201d quiere comunicarse con el equipo 192.168.5.14 (PC B) pero no sabe su MAC.  Utiliza el protocolo ARP para enviar un mensaje Broadcast (ARP Request) preguntando quien tiene asignada la IP 192.168.5.14.</p> <ol> <li> <p>Aquel equipo que tenga asignada dicha IP hace dos cosas:</p> <p>a.  Se guarda en su tabla ARP la direcci\u00f3n y MAC del solicitante.</p> <p>b.  Env\u00eda un mensaje ARP reply al solicitante inform\u00e1ndole de su MAC.</p> </li> </ol> <ol> <li>El PC A recibe el ARP reply y se anota en su tabla ARP la IP y la MAC del PC B. Ya pueden comunicarse con normalidad.</li> </ol> <p>Ejemplo de captura de tr\u00e1fico de un ARP request y un ARP reply.</p> Ejemplo, el 192.168.0.1 pregunta por la MAC del 192.168.0.11. <p>RARP</p> <p></p> El protocolo RARP (Reverse Address Resolution Protocol) es un protocol que permite averiguar una IP a partir de una MAC.  <p>\u00bfHace falta un router para que dos PCs se vean entre s\u00ed?</p> <p>No, no es necesario siempre y cuando est\u00e9n en la misma red. </p> <p>Mediante el protocolo ARP podemos averiguar por d\u00f3nde hay que enviar el paquete.</p> <p>Redes Diferentes</p> <p></p> Cuando queramos acceder a otra red diferente s\u00ed ser\u00e1 necesario un router.  <p>Tras hacer un ping de uno de los equipos al otro extremo, podemos observar que el switch almacena las MACs de ambos (el que manda el arp-request y el que contesta con el arp-reply).</p> <p>Depende de la memoria de los switches pueden almacenar m\u00e1s o menos MACs.</p> <p>Como podemos ver, el switch que usamos en el laboratorio puede almacenar muchas MACs, no obstante no todos los switches son as\u00ed.</p>"},{"location":"1_ConocimientosBasicos.html#tormenta-de-broadcast-bucles-de-red","title":"Tormenta de Broadcast / Bucles de red.","text":"<p>\u00bfQu\u00e9 pasa cuando un switch recibe una trama broadcast?</p> <p>Que redirige esa trama por todos los puertos excepto por aquel por el que recibi\u00f3 la trama.</p> <p>Ejemplo</p> <p>Tenemos un switch con 3 puertos: A, B y C.</p> <p>El puerto A est\u00e1 conectado a un PC.</p> <p>El puerto B y C est\u00e1n interconectados entre s\u00ed.</p> <p>1.  El equipo A env\u00eda un mensaje broadcast.</p> <p>2.  El switch reenv\u00eda dicho mensaje por los puertos B y C.</p> <p>3.  El switch recibe un broadcast del puerto B y lo reenv\u00eda por A y C.</p> <pre><code>i.  C reenv\u00eda el broadcast recibido a A y B.\n\n    ii. B reenv\u00eda el broadcast a A y C\n\n        iii.C reenv\u00eda el broadcast a A y B\n\n            iv. \u2026.\n</code></pre> <p>4.  A la vez recibe del puerto C el mismo broadcast y lo reenv\u00eda a A y B.</p> <pre><code>i.  B reenv\u00eda el broadcast recibido a A y C.\n\n    ii. C reenv\u00eda el broadcast a A y B\n\n      iii.  B reenv\u00eda el broadcast a A y C.\n\n          iv.   \u2026.\n</code></pre> <p>Lo que sucede es que en pocos segundos la red se inunda de mensajes broadcast, lo que colapsa de inmediato la red.</p> <p>Las tramas Ethernet de capa 2 no soportan ning\u00fan campo TTL (Time To Live), por lo que no saben si una trama ha estado durante mucho tiempo en la red saltando de switch en switch. Lo que no permite crear una pol\u00edtica que elimine tramas cuando hayan estado ya un tiempo en nuestra electr\u00f3nica de capa 2. Es decir, el bucle de red no se arregla hasta que elimines el bucle.</p>"},{"location":"A_ProblemasEVE.html","title":"Problemas Simulador","text":""},{"location":"A_ProblemasEVE.html#problemas-habituales-con-el-simulador","title":"Problemas habituales con el simulador.","text":""},{"location":"A_ProblemasEVE.html#sin-conexion-a-internet","title":"Sin conexi\u00f3n a Internet","text":"<p>Si al arrancar la m\u00e1quina se queda en un estado con el logo y pulsando F2 vemos que el error est\u00e1 en la tarjeta de red debemos hacer lo siguiente.</p> <p>Por ejemplo en caso de trabajar con un port\u00e1til no ser\u00e1 la misma configuraci\u00f3n si estamos usando nuestra red inal\u00e1mbrica o la al\u00e1mbrica. </p> <p>En la siguiente captura se ve c\u00f3mo podemos elegir la tarjeta de red inal\u00e1mbrica o la Ethernet.</p> <p>RED INAL\u00c1MBRICA</p> <p></p> En algunos casos es necesario usar la red cableada al dar problemas con los drivers de la red inal\u00e1mbrica."},{"location":"A_ProblemasEVE.html#kali-no-aplica-los-cambios-de-red","title":"Kali no aplica los cambios de red.","text":"<p>1. Comprobar nuestra direcci\u00f3n IP con el comando \u201cip a\u201d</p> <p>2.  Si hacemos una configuraci\u00f3n en la red, debemos reiniciar el servicio para que coja los cambios. Para ello lo m\u00e1s sencillo es desactivar y activar la red.</p>"},{"location":"A_ProblemasEVE.html#error-intel-vt-xept-o-amd-vrvi-al-abrir-la-maquina","title":"Error Intel VT-x/EPT o AMD-V/RVI al abrir la m\u00e1quina.","text":"<p>Si el simulador muestra este error al arrancar la m\u00e1quina, deberemos cerciorarnos de: </p> <p>1. Comprobar que est\u00e1 activada la opci\u00f3n en el VMWARE Player.</p> <p>2. Primero deberemos desactivar la integridad de memoria.</p> <p>Integridad de Memoria</p> <p></p> Es posible que una vez desactivada y reiniciada, cuando nos funcione el simulador, podamos volverla a activar.  <p>3.</p> <p>Desactivar del men\u00fa de caracter\u00edsticas de Windows el HyperV.</p> <p>Acto seguido, abrimos un powershell como administradores del sistema (bot\u00f3n derecho) y ejecutamos:</p> <p>4. Deshabilitar Virtualization-Based Security (VBS).</p> <p>Acceder al Editor de Pol\u00edticas de Grupo: Windows + R y ejecutar gpedit.msc.</p> <p>Navegar hasta la opci\u00f3n de \"Turn on Virtualization Based Security\" y deshabilitarla.</p> <p>Finalmente reiniciar.</p> <p>5. Comprobar que la virtualizaci\u00f3n est\u00e1 activada en la BIOS.</p>"},{"location":"A_ProblemasEVE.html#el-simulador-no-carga-la-web","title":"El simulador no carga la web.","text":"<p>Esto es posiblemente a que no hemos apagado el simulador de forma adecuada (shutdown \u2013h now) y hemos apagado o directamente o congelando la m\u00e1quina.</p> <p>Ante este problema hay que reconstruir la base de datos. Para ello ejecutar este comando.</p> <pre><code>unl_wrapper -a restoredb ; grep -q default_time_zone /etc/mysql/mysql.conf.d/mysqld.cnf || echo \"default_time_zone='+00:00'\" &gt;&gt; /etc/mysql/mysql.conf.d/mysqld.cnf ; systemctl restart mysql\n</code></pre>"}]}